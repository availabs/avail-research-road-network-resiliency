# https://geoffboeing.com/share/osmnx-paper.pdf
# https://geoffboeing.com/2016/11/osmnx-python-street-networks/

import os
import re
import subprocess
from os import PathLike
from typing import Optional

import shapely
from geopandas import GeoDataFrame

from common.us_census.tiger.utils import (
    get_buffered_region_gdf,
    get_geography_region_name,
    get_region_boundary_gdf,
)

this_dir = os.path.dirname(os.path.abspath(__file__))

OSMOSIS = os.path.join(this_dir, "../../lib/osmosis/latest/bin/osmosis")

DEFAULT_OSM_EXTRACT_BUFFER_DIST_MI = 10
DEFAULT_OSM_EXTRACTS_DIR = os.path.abspath(
    os.path.join(os.path.dirname(__file__), "../../data/processed/osm")
)


def get_osm_version_from_pbf_filename(osm_pbf: PathLike):
    osm_version_re = re.compile(r"[^0-9](?P<osm_version>\d{6})\.osm\.pbf$")

    s = str(osm_pbf)

    try:
        match = re.search(osm_version_re, s)

        osm_version = match.group("osm_version")

        return osm_version
    except Exception:
        raise ValueError(f"Invalid OSM PBF filename: {s}")


# Generated by ChatGPT
def output_osmosis_filter_poly(
    region_gdf: GeoDataFrame,  #
    out_filename: str,
) -> str:
    """
    Generates an Osmosis/Polygon Filter File (.poly) from a GeoDataFrame.
    Supports complex geometries, including those with holes.
    SEE: https://wiki.openstreetmap.org/wiki/Osmosis/Polygon_Filter_File_Format

    The .poly file format generated is:

        polygon_name
        <ring_id>
            lon lat
            lon lat
            ...
        END
        <ring_id>
            lon lat
            lon lat
            ...
        END
        ...
        END

    For a single polygon, the first ring is the exterior and subsequent rings (if any)
    are interior rings (holes). For a MultiPolygon, each polygon's rings are written
    sequentially with unique ring identifiers.

    Parameters
    ----------
    gdf : GeoDataFrame
        A GeoDataFrame containing polygon (or multipolygon) geometries.
    out_filename : str, optional
        The output filename for the .poly file. Should be a full path to the file.

    Returns
    -------
    str
        The output filename of the generated .poly file.

    Raises
    ------
    ValueError
        If the unified geometry is not a polygon or multipolygon.
    """
    # Combine all geometries into a single geometry (union)
    union_geom = shapely.ops.unary_union(
        region_gdf.to_crs(
            "EPSG:4326",  #
            inplace=False,
        ).geometry
    )

    # Prepare a list of polygons
    if union_geom.geom_type == "Polygon":
        polygons = [union_geom]
    elif union_geom.geom_type == "MultiPolygon":
        polygons = list(union_geom)
    else:
        raise ValueError("GeoDataFrame does not contain polygonal geometries.")

    if not out_filename.endswith(".poly"):
        out_filename += ".poly"

    # Get the name of the polygon
    polygon_name = os.path.splitext(os.path.basename(out_filename))[0]

    # Start building the file content as a list of lines.
    lines = [polygon_name]
    ring_counter = 1  # use a running counter to uniquely label each ring

    for poly in polygons:
        # Write the exterior ring first
        lines.append(f"{ring_counter}")
        ring_counter += 1
        for lon, lat in poly.exterior.coords:
            lines.append(f"    {lon} {lat}")
        lines.append("END")

        # Write any interior rings (holes)
        for interior in poly.interiors:
            lines.append(f"{ring_counter}")
            ring_counter += 1
            for lon, lat in interior.coords:
                lines.append(f"    {lon} {lat}")
            lines.append("END")

    # Final end line for the .poly file
    lines.append("END")

    # Write the lines to the specified output file
    with open(out_filename, "w") as f:
        f.write("\n".join(lines))

    return out_filename


def create_osm_region_road_network_extract_pbf(
    base_osm_pbf: os.PathLike,  #
    geoid: str,
    buffer_dist_mi: Optional[int] = DEFAULT_OSM_EXTRACT_BUFFER_DIST_MI,
    output_dir: Optional[os.PathLike] = DEFAULT_OSM_EXTRACTS_DIR,
    clean: bool = False,
) -> str:
    """
    Creates an OSM road network extract (PBF file) for a specified region.

    This function uses an input OSM PBF file and a US Census GEOID
    (geoid) to generate a road network extract for a region. A buffer
    distance (in miles) is applied to the region boundary, and an Osmosis
    polygon filter (.poly file) is created from the buffered boundary. The
    function then builds and runs an Osmosis command to extract major and
    minor roadways from the PBF file based on highway tags, and outputs the
    result to a new PBF file.

    Args:
        osm_pbf (os.PathLike): Path to the input OSM PBF file.
        geoid (str): US Census GEOID for the target region.
        buffer_dist_mi (int, optional): Buffer distance in miles around the
            region. Defaults to 10.
        output_dir (os.PathLike, optional): Directory in which output files are
            saved. Defaults to the current working directory.

    Returns:
        str: The path to the output extracted OSM PBF file.

    Raises:
        subprocess.CalledProcessError: If the Osmosis subprocess fails.
    """

    region_name = get_geography_region_name(geoid=geoid, buffer_dist_mi=buffer_dist_mi)

    region_gdf = get_region_boundary_gdf(geoid)

    buffered_region_gdf = get_buffered_region_gdf(
        region_gdf=region_gdf,  #
        buffer_dist_mi=buffer_dist_mi,
    )

    poly_filename = os.path.join(output_dir, f"{region_name}.poly")

    output_file_basename = (
        f"nonservice-roadways-{region_name}_{os.path.basename(base_osm_pbf)}"
    )

    output_file = os.path.join(output_dir, output_file_basename)

    if os.path.exists(output_file):
        if clean:
            os.remove(output_file)
        else:
            return output_file

    output_osmosis_filter_poly(
        region_gdf=buffered_region_gdf,  #
        out_filename=poly_filename,
    )

    # https://wiki.openstreetmap.org/wiki/Key:highway
    major_roadways = [
        "motorway",
        "motorway_link",
        "motorway_junction",
        "trunk",
        "trunk_link",
        "primary",
        "primary_link",
        "secondary",
        "secondary_link",
        "tertiary",
        "tertiary_link",
    ]

    # NOTE: Excluding "service" roads.
    minor_roadways = ["residential", "living_street", "unclassified"]

    included_highways = ",".join(major_roadways + minor_roadways)

    # https://github.com/openstreetmap/osmosis/blob/main/doc/detailed-usage.adoc
    osmium_extract_cmd = [
        OSMOSIS,
        "--read-pbf-fast",
        base_osm_pbf,
        "--sort",
        "type=TypeThenId",
        "--bounding-polygon",
        f"file={poly_filename}",
        "completeWays=yes",
        "completeRelations=no",
        "--tag-filter",
        "accept-ways",
        f"highway={included_highways}",
        "--used-node",
        "--buffer",
        "500",
        "--write-pbf",
        output_file,
    ]

    log_filename = f"{output_file[: -len('.osm.pbf')]}.extract.log"

    with open(log_filename, "w") as log_file:
        try:
            subprocess.run(
                args=osmium_extract_cmd,  # The Osmosis command to run
                stdout=log_file,  # Pipe STDOUT to a log file
                stderr=log_file,  # Pipe STDERR to the same log file
                shell=False,  # Do not use shell to avoid shell injection vulnerabilities
                check=True,  # raise an error if the command fails
            )
        except subprocess.CalledProcessError as e:
            relative_path = os.path.relpath(OSMOSIS, os.getcwd())
            print(f"Error running Osmosis. Check the logfile: {log_filename}")
            print(f"Command: {'\n\t'.join([relative_path] + osmium_extract_cmd[1:])}")
            raise

    return output_file
